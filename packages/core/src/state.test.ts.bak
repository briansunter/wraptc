import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import { StateManager } from "./state";
import type { FullState } from "./types";
import { mkdir, readFile, writeFile, unlink } from "node:fs/promises";
import { join } from "node:path";

describe("StateManager", () => {
  let stateManager: StateManager;
  const tempStatePath = "/tmp/test-state.json";
  const tempStateDir = "/tmp/test-state-dir";

  beforeEach(async () => {
    // Clean up any existing test files
    try {
      await unlink(tempStatePath);
    } catch {
      // File doesn't exist, that's fine
    }

    try {
      await unlink(join(tempStateDir, "state.json"));
    } catch {
      // File doesn't exist, that's fine
    }

    stateManager = new StateManager({ statePath: tempStatePath });
  });

  afterEach(async () => {
    // Clean up test files after each test
    try {
      await unlink(tempStatePath);
    } catch {
      // File doesn't exist, that's fine
    }

    try {
      await unlink(join(tempStateDir, "state.json"));
    } catch {
      // File doesn't exist, that's fine
    }
  });

  describe("Basic functionality", () => {
    test("can create StateManager instance", () => {
      expect(stateManager).toBeDefined();
      expect(stateManager).toBeInstanceOf(StateManager);
    });

    test("has getState method", () => {
      expect(typeof (stateManager as any).getState).toBe("function");
    });

    test("has getStatePath method", () => {
      expect(typeof (stateManager as any).getStatePath).toBe("function");
    });

    test("can call getState", () => {
      const state = (stateManager as any).getState();
      expect(state).toBeDefined();
      expect(state.version).toBe("1.0.0");
      expect(state.providers).toEqual({});
    });

    test("can call getStatePath", () => {
      const path = (stateManager as any).getStatePath();
      expect(path).toBe(tempStatePath);
    });
  });

  describe("Initialization", () => {
    test("creates initial state when file doesn't exist", async () => {
      await stateManager.initialize();

      const state = (stateManager as any).getState();
      expect(state).toBeDefined();
      expect(state.version).toBe("1.0.0");
      expect(state.providers).toEqual({});
    });

    test("loads existing state from file", async () => {
      // Create a test state file with today's date to prevent reset
      const today = new Date();
      const todayISO = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate(),
      ).toISOString();

      const testState: FullState = {
        version: "1.0.0",
        providers: {
          "test-provider": {
            lastUsedAt: todayISO,
            requestsToday: 5,
            lastReset: todayISO,
            outOfCreditsUntil: undefined,
            lastErrors: ["error1", "error2"],
          },
        },
      };

      await mkdir(tempStatePath.split("/").slice(0, -1).join("/"), { recursive: true });
      await writeFile(tempStatePath, JSON.stringify(testState, null, 2), "utf-8");

      // Create new state manager to load the file
      const newStateManager = new StateManager({ statePath: tempStatePath });
      await newStateManager.initialize();

      const state = (newStateManager as any).getState();
      expect(state).toBeDefined();
      expect(state.version).toBe("1.0.0");
      expect(state.providers["test-provider"]).toBeDefined();
      expect(state.providers["test-provider"].requestsToday).toBe(5);
      expect(state.providers["test-provider"].lastErrors).toEqual(["error1", "error2"]);
    });

    test("handles invalid JSON in state file gracefully", async () => {
      // Create an invalid state file
      await mkdir(tempStatePath.split("/").slice(0, -1).join("/"), { recursive: true });
      await writeFile(tempStatePath, '{"invalid": json}', "utf-8");

      // Should throw an error when trying to parse invalid JSON
      await expect(stateManager.initialize()).rejects.toThrow();
    });

    test("handles file read errors gracefully", async () => {
      // This test acknowledges that some file system errors may occur
      // but the state manager should handle them gracefully
      expect(true).toBe(true); // Placeholder - actual testing would require mocking
    });
  });

  describe("getProviderState", () => {
    test("can call getProviderState for new provider", async () => {
      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state).toBeDefined();
      expect(state.requestsToday).toBe(0);
      expect(state.lastErrors).toEqual([]);
      expect(state.outOfCreditsUntil).toBeUndefined();
    });

    test("returns existing provider state", async () => {
      // First call creates the provider
      await (stateManager as any).getProviderState("test-provider");

      // Second call should return the same state
      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state).toBeDefined();
      expect(state.requestsToday).toBe(0);
    });
  });

  describe("recordSuccess", () => {
    test("can call recordSuccess", async () => {
      await (stateManager as any).recordSuccess("test-provider");
    });

    test("increments request count", async () => {
      await (stateManager as any).recordSuccess("test-provider");
      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.requestsToday).toBe(1);
    });

    test("updates lastUsedAt", async () => {
      const before = new Date();
      await (stateManager as any).recordSuccess("test-provider");
      const after = new Date();

      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.lastUsedAt).toBeDefined();
      const lastUsedAt = new Date(state.lastUsedAt!);
      expect(lastUsedAt.getTime()).toBeGreaterThanOrEqual(before.getTime());
      expect(lastUsedAt.getTime()).toBeLessThanOrEqual(after.getTime());
    });

    test("clears lastErrors on success", async () => {
      // Add an error first
      await (stateManager as any).recordError("test-provider", "TRANSIENT", "test error");

      // Then record success
      await (stateManager as any).recordSuccess("test-provider");

      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.lastErrors).toEqual([]);
    });
  });

  describe("recordError", () => {
    test("can call recordError", async () => {
      await (stateManager as any).recordError("test-provider", "TRANSIENT", "test error");
    });

    test("records error in lastErrors", async () => {
      await (stateManager as any).recordError("test-provider", "TRANSIENT", "test error");
      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.lastErrors.length).toBe(1);
      expect(state.lastErrors[0]).toContain("TRANSIENT");
      expect(state.lastErrors[0]).toContain("test error");
    });

    test("limits error history to 10 errors", async () => {
      // Add 15 errors
      for (let i = 0; i < 15; i++) {
        await (stateManager as any).recordError("test-provider", "TRANSIENT", `error ${i}`);
      }

      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.lastErrors.length).toBe(10);
      // Should keep the last 10 errors
      expect(state.lastErrors[0]).toContain("error 5");
      expect(state.lastErrors[9]).toContain("error 14");
    });
  });

  describe("markOutOfCredits", () => {
    test("can call markOutOfCredits", async () => {
      const futureDate = new Date(Date.now() + 3600000);
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);
    });

    test("sets outOfCreditsUntil", async () => {
      const futureDate = new Date(Date.now() + 3600000);
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);
      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBe(futureDate.toISOString());
    });
  });

  describe("resetProvider", () => {
    test("can call resetProvider", async () => {
      await (stateManager as any).resetProvider("test-provider");
    });

    test("resets provider state", async () => {
      // Set up some state
      await (stateManager as any).recordSuccess("test-provider");
      await (stateManager as any).recordError("test-provider", "TRANSIENT", "error");
      const futureDate = new Date(Date.now() + 3600000);
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);

      // Reset
      await (stateManager as any).resetProvider("test-provider");

      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.requestsToday).toBe(0);
      expect(state.lastErrors).toEqual([]);
      expect(state.outOfCreditsUntil).toBeUndefined();
    });
  });

  describe("resetAll", () => {
    test("can call resetAll", async () => {
      await (stateManager as any).resetAll();
    });

    test("resets all state", async () => {
      // Add some state
      await (stateManager as any).getProviderState("provider1");
      await (stateManager as any).getProviderState("provider2");

      await (stateManager as any).resetAll();

      const state = (stateManager as any).getState();
      expect(state.providers).toEqual({});
    });
  });

  describe("Persistence and File Operations", () => {
    test("saves state to file", async () => {
      // Record some activity
      await (stateManager as any).recordSuccess("test-provider");
      await (stateManager as any).recordError("test-provider", "TRANSIENT", "test error");

      // Force immediate save by calling save directly
      await (stateManager as any).save();

      // Check that file was created
      const fileContent = await readFile(tempStatePath, "utf-8");
      const savedState = JSON.parse(fileContent);

      expect(savedState).toBeDefined();
      expect(savedState.version).toBe("1.0.0");
      expect(savedState.providers["test-provider"]).toBeDefined();
      expect(savedState.providers["test-provider"].requestsToday).toBe(1);
      expect(savedState.providers["test-provider"].lastErrors.length).toBe(1);
    });

    test("performs atomic file operations", async () => {
      // Record some activity
      await (stateManager as any).recordSuccess("test-provider");

      // Force immediate save
      await (stateManager as any).save();

      // Check that temp file was cleaned up
      let tempFileExists = false;
      try {
        await readFile(`${tempStatePath}.tmp`, "utf-8");
        tempFileExists = true;
      } catch (error) {
        // This is expected - temp file should not exist
        expect((error as NodeJS.ErrnoException).code).toBe("ENOENT");
      }

      if (tempFileExists) {
        throw new Error("Temporary file should have been cleaned up");
      }

      // Check that main file exists
      const fileContent = await readFile(tempStatePath, "utf-8");
      const savedState = JSON.parse(fileContent);
      expect(savedState.providers["test-provider"]).toBeDefined();
    });

    test("creates directory structure if it doesn't exist", async () => {
      const nestedPath = join(tempStateDir, "subdir", "state.json");
      const nestedStateManager = new StateManager({ statePath: nestedPath });

      // Record some activity
      await (nestedStateManager as any).recordSuccess("test-provider");

      // Force immediate save
      await (nestedStateManager as any).save();

      // Check that file was created in nested directory
      const fileContent = await readFile(nestedPath, "utf-8");
      const savedState = JSON.parse(fileContent);
      expect(savedState.providers["test-provider"]).toBeDefined();
    });

    test("handles file write errors gracefully", async () => {
      // Create state manager with a path in a read-only directory
      // This is a bit tricky to test without actually having a read-only directory
      // We'll acknowledge this is tested indirectly through other mechanisms
      expect(true).toBe(true); // Placeholder - actual testing would require specific setup
    });

    test("debounces saves to avoid too many writes", async () => {
      // Record multiple activities quickly
      await (stateManager as any).recordSuccess("test-provider-1");
      await (stateManager as any).recordSuccess("test-provider-2");
      await (stateManager as any).recordError("test-provider-1", "TRANSIENT", "test error");

      // Wait for debounce period to complete
      await new Promise((resolve) => setTimeout(resolve, 1100));

      // Check that file was saved
      const fileContent = await readFile(tempStatePath, "utf-8");
      const savedState = JSON.parse(fileContent);

      expect(savedState.providers["test-provider-1"]).toBeDefined();
      expect(savedState.providers["test-provider-2"]).toBeDefined();
      expect(savedState.providers["test-provider-1"].lastErrors.length).toBe(1);
    });
  });

  describe("Daily Counter Reset", () => {
    test("resets daily counters when needed", async () => {
      // Create a state file with old data
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayISO = new Date(
        yesterday.getFullYear(),
        yesterday.getMonth(),
        yesterday.getDate(),
      ).toISOString();

      const testState: FullState = {
        version: "1.0.0",
        providers: {
          "test-provider": {
            lastUsedAt: yesterday.toISOString(),
            requestsToday: 10,
            lastReset: yesterdayISO,
            outOfCreditsUntil: new Date(Date.now() + 3600000).toISOString(),
            lastErrors: ["old error"],
          },
        },
      };

      await mkdir(tempStatePath.split("/").slice(0, -1).join("/"), { recursive: true });
      await writeFile(tempStatePath, JSON.stringify(testState, null, 2), "utf-8");

      // Create new state manager to load the file
      const newStateManager = new StateManager({ statePath: tempStatePath });
      await newStateManager.initialize();

      const state = (newStateManager as any).getState();
      const providerState = state.providers["test-provider"];

      // Daily counters should be reset because lastReset was yesterday
      expect(providerState.requestsToday).toBe(0);
      expect(providerState.outOfCreditsUntil).toBeUndefined();
      // But errors should be preserved until explicitly cleared
      expect(providerState.lastErrors).toEqual(["old error"]);
    });

    test("preserves daily counters when not needed", async () => {
      // Create a state file with today's data
      const today = new Date();
      const todayISO = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate(),
      ).toISOString();

      const testState: FullState = {
        version: "1.0.0",
        providers: {
          "test-provider": {
            lastUsedAt: today.toISOString(),
            requestsToday: 5,
            lastReset: todayISO,
            outOfCreditsUntil: undefined,
            lastErrors: ["recent error"],
          },
        },
      };

      await mkdir(tempStatePath.split("/").slice(0, -1).join("/"), { recursive: true });
      await writeFile(tempStatePath, JSON.stringify(testState, null, 2), "utf-8");

      // Create new state manager to load the file
      const newStateManager = new StateManager({ statePath: tempStatePath });
      await newStateManager.initialize();

      const state = (newStateManager as any).getState();
      const providerState = state.providers["test-provider"];

      // Daily counters should be preserved because lastReset was today
      expect(providerState.requestsToday).toBe(5);
      expect(providerState.lastErrors).toEqual(["recent error"]);
    });

    test("manual reset clears provider counters", async () => {
      // Set up some state
      await (stateManager as any).recordSuccess("test-provider");
      await (stateManager as any).recordSuccess("test-provider");
      await (stateManager as any).recordError("test-provider", "TRANSIENT", "test error");

      const futureDate = new Date(Date.now() + 3600000);
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);

      // Verify state before reset
      let state = await (stateManager as any).getProviderState("test-provider");
      expect(state.requestsToday).toBe(2);
      expect(state.lastErrors.length).toBe(1);
      expect(state.outOfCreditsUntil).toBeDefined();

      // Manual reset
      await (stateManager as any).resetProvider("test-provider");

      // Verify state after reset
      state = await (stateManager as any).getProviderState("test-provider");
      expect(state.requestsToday).toBe(0);
      expect(state.lastErrors).toEqual([]);
      expect(state.outOfCreditsUntil).toBeUndefined();
    });

    test("manual reset preserves other provider states", async () => {
      // Set up state for two providers
      await (stateManager as any).recordSuccess("provider-1");
      await (stateManager as any).recordSuccess("provider-1");
      await (stateManager as any).recordSuccess("provider-2");
      await (stateManager as any).recordError("provider-1", "TRANSIENT", "error1");
      await (stateManager as any).recordError("provider-2", "PERMANENT", "error2");

      // Verify state before reset
      let state1 = await (stateManager as any).getProviderState("provider-1");
      let state2 = await (stateManager as any).getProviderState("provider-2");
      expect(state1.requestsToday).toBe(2);
      expect(state2.requestsToday).toBe(1);
      expect(state1.lastErrors.length).toBe(1);
      expect(state2.lastErrors.length).toBe(1);

      // Reset only provider-1
      await (stateManager as any).resetProvider("provider-1");

      // Verify that provider-1 is reset but provider-2 is unchanged
      state1 = await (stateManager as any).getProviderState("provider-1");
      state2 = await (stateManager as any).getProviderState("provider-2");
      expect(state1.requestsToday).toBe(0);
      expect(state1.lastErrors).toEqual([]);
      expect(state2.requestsToday).toBe(1);
      expect(state2.lastErrors.length).toBe(1);
      expect(state2.lastErrors[0]).toContain("error2");
    });

    test("counter persistence across multiple operations", async () => {
      // Record several successes
      await (stateManager as any).recordSuccess("test-provider");
      await (stateManager as any).recordSuccess("test-provider");
      await (stateManager as any).recordSuccess("test-provider");

      // Check counter
      let state = await (stateManager as any).getProviderState("test-provider");
      expect(state.requestsToday).toBe(3);
      expect(state.lastErrors.length).toBe(0); // No errors yet

      // Record an error (should not affect counter)
      await (stateManager as any).recordError("test-provider", "TRANSIENT", "test error");
      state = await (stateManager as any).getProviderState("test-provider");
      expect(state.requestsToday).toBe(3);
      expect(state.lastErrors.length).toBe(1);

      // Record more successes (this should clear errors)
      await (stateManager as any).recordSuccess("test-provider");
      await (stateManager as any).recordSuccess("test-provider");

      // Check final counter
      state = await (stateManager as any).getProviderState("test-provider");
      expect(state.requestsToday).toBe(5);
      expect(state.lastErrors.length).toBe(0); // Errors should be cleared by success
    });

    test("edge case: midnight transition", async () => {
      // Create a state file with yesterday's date at 23:59:59
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      yesterday.setHours(23, 59, 59, 999); // Just before midnight

      const yesterdayMidnight = new Date(
        yesterday.getFullYear(),
        yesterday.getMonth(),
        yesterday.getDate(),
      );

      const testState: FullState = {
        version: "1.0.0",
        providers: {
          "test-provider": {
            lastUsedAt: yesterday.toISOString(),
            requestsToday: 15,
            lastReset: yesterdayMidnight.toISOString(),
            outOfCreditsUntil: undefined,
            lastErrors: ["midnight error"],
          },
        },
      };

      await mkdir(tempStatePath.split("/").slice(0, -1).join("/"), { recursive: true });
      await writeFile(tempStatePath, JSON.stringify(testState, null, 2), "utf-8");

      // Create new state manager to load the file
      const newStateManager = new StateManager({ statePath: tempStatePath });
      await newStateManager.initialize();

      const state = (newStateManager as any).getState();
      const providerState = state.providers["test-provider"];

      // Counters should be reset because we crossed midnight
      expect(providerState.requestsToday).toBe(0);
      expect(providerState.lastErrors).toEqual(["midnight error"]); // Preserved
    });

    test("edge case: provider with no lastReset date", async () => {
      // Create a state file with a provider that has no lastReset date
      const testState: FullState = {
        version: "1.0.0",
        providers: {
          "test-provider": {
            lastUsedAt: new Date().toISOString(),
            requestsToday: 7,
            lastReset: undefined,
            outOfCreditsUntil: undefined,
            lastErrors: ["no-reset error"],
          },
        },
      };

      await mkdir(tempStatePath.split("/").slice(0, -1).join("/"), { recursive: true });
      await writeFile(tempStatePath, JSON.stringify(testState, null, 2), "utf-8");

      // Create new state manager to load the file
      const newStateManager = new StateManager({ statePath: tempStatePath });
      await newStateManager.initialize();

      const state = (newStateManager as any).getState();
      const providerState = state.providers["test-provider"];

      // Counters should be reset because there was no lastReset date
      expect(providerState.requestsToday).toBe(0);
      expect(providerState.lastErrors).toEqual(["no-reset error"]); // Preserved
    });

    test("edge case: multiple providers with different reset needs", async () => {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayISO = new Date(
        yesterday.getFullYear(),
        yesterday.getMonth(),
        yesterday.getDate(),
      ).toISOString();

      const today = new Date();
      const todayISO = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate(),
      ).toISOString();

      const testState: FullState = {
        version: "1.0.0",
        providers: {
          "yesterday-provider": {
            lastUsedAt: yesterday.toISOString(),
            requestsToday: 12,
            lastReset: yesterdayISO,
            outOfCreditsUntil: new Date(Date.now() + 3600000).toISOString(),
            lastErrors: ["yesterday error"],
          },
          "today-provider": {
            lastUsedAt: today.toISOString(),
            requestsToday: 8,
            lastReset: todayISO,
            outOfCreditsUntil: undefined,
            lastErrors: ["today error"],
          },
          "no-reset-provider": {
            lastUsedAt: today.toISOString(),
            requestsToday: 5,
            lastReset: undefined,
            outOfCreditsUntil: undefined,
            lastErrors: ["no reset error"],
          },
        },
      };

      await mkdir(tempStatePath.split("/").slice(0, -1).join("/"), { recursive: true });
      await writeFile(tempStatePath, JSON.stringify(testState, null, 2), "utf-8");

      // Create new state manager to load the file
      const newStateManager = new StateManager({ statePath: tempStatePath });
      await newStateManager.initialize();

      const state = (newStateManager as any).getState();

      // yesterday-provider and no-reset-provider should be reset
      const yesterdayProvider = state.providers["yesterday-provider"];
      expect(yesterdayProvider.requestsToday).toBe(0);
      expect(yesterdayProvider.outOfCreditsUntil).toBeUndefined();
      expect(yesterdayProvider.lastErrors).toEqual(["yesterday error"]);

      // today-provider should be preserved
      const todayProvider = state.providers["today-provider"];
      expect(todayProvider.requestsToday).toBe(8);
      expect(todayProvider.lastErrors).toEqual(["today error"]);

      // no-reset-provider should be reset
      const noResetProvider = state.providers["no-reset-provider"];
      expect(noResetProvider.requestsToday).toBe(0);
      expect(noResetProvider.lastErrors).toEqual(["no reset error"]);
    });
  });

  describe("Multiple Providers State Recording", () => {
    test("tracks state for multiple providers independently", async () => {
      // Record activity for multiple providers
      await (stateManager as any).recordSuccess("provider-a");
      await (stateManager as any).recordSuccess("provider-a");
      await (stateManager as any).recordSuccess("provider-b");
      await (stateManager as any).recordError("provider-a", "TRANSIENT", "error a");
      await (stateManager as any).recordError("provider-b", "PERMANENT", "error b");
      await (stateManager as any).recordError("provider-b", "TRANSIENT", "error b2");

      // Check provider-a state
      const stateA = await (stateManager as any).getProviderState("provider-a");
      expect(stateA.requestsToday).toBe(2);
      expect(stateA.lastErrors.length).toBe(1);
      expect(stateA.lastErrors[0]).toContain("error a");

      // Check provider-b state
      const stateB = await (stateManager as any).getProviderState("provider-b");
      expect(stateB.requestsToday).toBe(1);
      expect(stateB.lastErrors.length).toBe(2);
      expect(stateB.lastErrors[0]).toContain("error b");
      expect(stateB.lastErrors[1]).toContain("error b2");

      // Record more successes for provider-a (should clear errors)
      await (stateManager as any).recordSuccess("provider-a");
      const updatedStateA = await (stateManager as any).getProviderState("provider-a");
      expect(updatedStateA.requestsToday).toBe(3);
      expect(updatedStateA.lastErrors.length).toBe(0);
    });

    test("maintains separate out of credits states", async () => {
      const futureDateA = new Date(Date.now() + 3600000);
      const futureDateB = new Date(Date.now() + 7200000);

      await (stateManager as any).markOutOfCredits("provider-a", futureDateA);
      await (stateManager as any).markOutOfCredits("provider-b", futureDateB);

      const stateA = await (stateManager as any).getProviderState("provider-a");
      const stateB = await (stateManager as any).getProviderState("provider-b");

      expect(stateA.outOfCreditsUntil).toBe(futureDateA.toISOString());
      expect(stateB.outOfCreditsUntil).toBe(futureDateB.toISOString());
    });

    test("resets individual providers without affecting others", async () => {
      // Set up state for multiple providers
      await (stateManager as any).recordSuccess("provider-a");
      await (stateManager as any).recordSuccess("provider-a");
      await (stateManager as any).recordSuccess("provider-b");
      await (stateManager as any).recordError("provider-a", "TRANSIENT", "error a");
      await (stateManager as any).recordError("provider-b", "PERMANENT", "error b");

      // Reset only provider-a
      await (stateManager as any).resetProvider("provider-a");

      // Check provider-a is reset
      const stateA = await (stateManager as any).getProviderState("provider-a");
      expect(stateA.requestsToday).toBe(0);
      expect(stateA.lastErrors.length).toBe(0);

      // Check provider-b is unaffected
      const stateB = await (stateManager as any).getProviderState("provider-b");
      expect(stateB.requestsToday).toBe(1);
      expect(stateB.lastErrors.length).toBe(1);
      expect(stateB.lastErrors[0]).toContain("error b");
    });
  });

  describe("Credit Limit Enforcement", () => {
    test("correctly tracks out of credits state", async () => {
      const futureDate = new Date(Date.now() + 3600000); // 1 hour in the future
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);

      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBe(futureDate.toISOString());
    });

    test("allows clearing out of credits state through reset", async () => {
      const futureDate = new Date(Date.now() + 3600000);
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);

      // Verify it's set
      let state = await (stateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBeDefined();

      // Reset provider
      await (stateManager as any).resetProvider("test-provider");

      // Verify it's cleared
      state = await (stateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBeUndefined();
    });

    test("persists out of credits state across sessions", async () => {
      const futureDate = new Date(Date.now() + 3600000);
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);

      // Force immediate save
      await (stateManager as any).save();

      // Create new state manager to simulate new session
      const newStateManager = new StateManager({ statePath: tempStatePath });
      await newStateManager.initialize();

      const state = await (newStateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBe(futureDate.toISOString());
    });
  });

  describe("Out of Credits Functionality", () => {
    test("detects when provider is out of credits", async () => {
      const futureDate = new Date(Date.now() + 3600000); // 1 hour in the future
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);
      await (stateManager as any).save(); // Force immediate save

      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBe(futureDate.toISOString());
      
      // Verify that the out of credits state is properly detected
      const isOutOfCredits = state.outOfCreditsUntil && new Date(state.outOfCreditsUntil) > new Date();
      expect(isOutOfCredits).toBe(true);
    });

    test("allows requests when provider is not out of credits", async () => {
      const pastDate = new Date(Date.now() - 3600000); // 1 hour ago
      await (stateManager as any).markOutOfCredits("test-provider", pastDate);
      await (stateManager as any).save(); // Force immediate save

      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBe(pastDate.toISOString());
      
      // Verify that the out of credits state is properly detected as expired
      const isOutOfCredits = state.outOfCreditsUntil && new Date(state.outOfCreditsUntil) > new Date();
      expect(isOutOfCredits).toBe(false);
    });

    test("enforces credit limits by marking provider as out of credits", async () => {
      // Simulate reaching daily limit
      for (let i = 0; i < 10; i++) {
        await (stateManager as any).recordSuccess("test-provider");
      }
      await (stateManager as any).save(); // Force immediate save

      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.requestsToday).toBe(10);
      
      // Mark as out of credits
      const futureDate = new Date(Date.now() + 86400000); // 24 hours in the future
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);
      await (stateManager as any).save(); // Force immediate save
      
      const updatedState = await (stateManager as any).getProviderState("test-provider");
      expect(updatedState.outOfCreditsUntil).toBe(futureDate.toISOString());
    });
  });

    test("allows requests when provider is not out of credits", async () => {
      const pastDate = new Date(Date.now() - 3600000); // 1 hour ago
      await (stateManager as any).markOutOfCredits("test-provider", pastDate);

      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBe(pastDate.toISOString());

      // Verify that the out of credits state is properly detected as expired
      const isOutOfCredits =
        state.outOfCreditsUntil && new Date(state.outOfCreditsUntil) > new Date();
      expect(isOutOfCredits).toBe(false);
    });

    test("enforces credit limits by marking provider as out of credits", async () => {
      // Simulate reaching daily limit
      for (let i = 0; i < 10; i++) {
        await (stateManager as any).recordSuccess("test-provider");
      }

      const state = await (stateManager as any).getProviderState("test-provider");
      expect(state.requestsToday).toBe(10);

      // Mark as out of credits
      const futureDate = new Date(Date.now() + 86400000); // 24 hours in the future
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);

      const updatedState = await (stateManager as any).getProviderState("test-provider");
      expect(updatedState.outOfCreditsUntil).toBe(futureDate.toISOString());
    });
  });

  describe("Out of Credits State Persistence", () => {
    test("persists out of credits state to file", async () => {
      const futureDate = new Date(Date.now() + 3600000);
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);

      // Force immediate save
      await (stateManager as any).save();

      // Read the file directly to verify persistence
      const fileContent = await readFile(tempStatePath, "utf-8");
      const savedState = JSON.parse(fileContent);

      expect(savedState.providers["test-provider"]).toBeDefined();
      expect(savedState.providers["test-provider"].outOfCreditsUntil).toBe(
        futureDate.toISOString(),
      );
    });

    test("loads out of credits state from file", async () => {
      const futureDate = new Date(Date.now() + 3600000);
      const testState = {
        version: "1.0.0",
        providers: {
          "test-provider": {
            lastUsedAt: new Date().toISOString(),
            requestsToday: 5,
            lastReset: new Date().toISOString(),
            outOfCreditsUntil: futureDate.toISOString(),
            lastErrors: [],
          },
        },
      };

      await mkdir(tempStatePath.split("/").slice(0, -1).join("/"), { recursive: true });
      await writeFile(tempStatePath, JSON.stringify(testState, null, 2), "utf-8");

      // Create new state manager to load the file
      const newStateManager = new StateManager({ statePath: tempStatePath });
      await newStateManager.initialize();

      const state = await (newStateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBe(futureDate.toISOString());
    });

    test("preserves out of credits state across multiple sessions", async () => {
      const futureDate = new Date(Date.now() + 86400000); // 24 hours in the future
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);

      // Force save
      await (stateManager as any).save();

      // Create multiple state managers to simulate multiple sessions
      for (let i = 0; i < 3; i++) {
        const newStateManager = new StateManager({ statePath: tempStatePath });
        await newStateManager.initialize();

        const state = await (newStateManager as any).getProviderState("test-provider");
        expect(state.outOfCreditsUntil).toBe(futureDate.toISOString());
      }
    });
  });

  describe("Credit Reset Functionality", () => {
    test("resets out of credits state when provider is reset", async () => {
      const futureDate = new Date(Date.now() + 3600000);
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);

      // Verify state before reset
      let state = await (stateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBe(futureDate.toISOString());
      expect(state.requestsToday).toBe(0);

      // Add some requests
      await (stateManager as any).recordSuccess("test-provider");
      await (stateManager as any).recordSuccess("test-provider");

      state = await (stateManager as any).getProviderState("test-provider");
      expect(state.requestsToday).toBe(2);

      // Reset provider
      await (stateManager as any).resetProvider("test-provider");

      // Verify state after reset
      state = await (stateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBeUndefined();
      expect(state.requestsToday).toBe(0);
      expect(state.lastErrors).toEqual([]);
    });

    test("resets out of credits state when all state is reset", async () => {
      const futureDate = new Date(Date.now() + 3600000);
      await (stateManager as any).markOutOfCredits("test-provider", futureDate);

      // Add some requests
      await (stateManager as any).recordSuccess("test-provider");
      await (stateManager as any).recordSuccess("test-provider");

      // Verify state before reset
      let state = await (stateManager as any).getProviderState("test-provider");
      expect(state.outOfCreditsUntil).toBe(futureDate.toISOString());
      expect(state.requestsToday).toBe(2);

      // Reset all state
      await (stateManager as any).resetAll();

      // Verify state after reset
      const fullState = (stateManager as any).getState();
      expect(fullState.providers["test-provider"]).toBeUndefined();
    });

    test("resets out of credits state during daily counter reset", async () => {
      // Create a state file with old data
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayISO = new Date(
        yesterday.getFullYear(),
        yesterday.getMonth(),
        yesterday.getDate(),
      ).toISOString();

      const futureDate = new Date(Date.now() + 3600000);
      const testState = {
        version: "1.0.0",
        providers: {
          "test-provider": {
            lastUsedAt: yesterday.toISOString(),
            requestsToday: 10,
            lastReset: yesterdayISO,
            outOfCreditsUntil: futureDate.toISOString(),
            lastErrors: ["old error"],
          },
        },
      };

      await mkdir(tempStatePath.split("/").slice(0, -1).join("/"), { recursive: true });
      await writeFile(tempStatePath, JSON.stringify(testState, null, 2), "utf-8");

      // Create new state manager to load the file
      const newStateManager = new StateManager({ statePath: tempStatePath });
      await newStateManager.initialize();

      const state = (newStateManager as any).getState();
      const providerState = state.providers["test-provider"];

      // Daily counters and out of credits should be reset because lastReset was yesterday
      expect(providerState.requestsToday).toBe(0);
      expect(providerState.outOfCreditsUntil).toBeUndefined();
      // But errors should be preserved until explicitly cleared
      expect(providerState.lastErrors).toEqual(["old error"]);
    });
  });

  describe("Provider Selection When Credits Are Exhausted", () => {
    test("skips providers that are out of credits", async () => {
      const futureDate = new Date(Date.now() + 3600000);
      await (stateManager as any).markOutOfCredits("out-of-credits-provider", futureDate);

      // Add another provider that is not out of credits
      await (stateManager as any).getProviderState("available-provider");

      // Check states
      const outOfCreditsState = await (stateManager as any).getProviderState(
        "out-of-credits-provider",
      );
      const availableState = await (stateManager as any).getProviderState("available-provider");

      // Verify out of credits provider is marked as such
      const isOutOfCredits =
        outOfCreditsState.outOfCreditsUntil &&
        new Date(outOfCreditsState.outOfCreditsUntil) > new Date();
      expect(isOutOfCredits).toBe(true);

      // Verify available provider is not marked as out of credits
      const isAvailableOutOfCredits =
        availableState.outOfCreditsUntil && new Date(availableState.outOfCreditsUntil) > new Date();
      expect(isAvailableOutOfCredits).toBe(false);
    });

    test("allows selection of providers that have expired out of credits", async () => {
      const pastDate = new Date(Date.now() - 3600000); // 1 hour ago
      await (stateManager as any).markOutOfCredits("expired-provider", pastDate);

      const state = await (stateManager as any).getProviderState("expired-provider");

      // Verify provider is not considered out of credits anymore
      const isOutOfCredits =
        state.outOfCreditsUntil && new Date(state.outOfCreditsUntil) > new Date();
      expect(isOutOfCredits).toBe(false);
    });

    test("properly handles multiple providers with mixed credit states", async () => {
      const futureDate = new Date(Date.now() + 3600000);
      const pastDate = new Date(Date.now() - 3600000);

      // Mark one provider as out of credits
      await (stateManager as any).markOutOfCredits("out-of-credits-provider", futureDate);

      // Mark another provider as having expired out of credits
      await (stateManager as any).markOutOfCredits("expired-provider", pastDate);

      // Leave third provider with no out of credits state

      // Check states
      const outOfCreditsState = await (stateManager as any).getProviderState(
        "out-of-credits-provider",
      );
      const expiredState = await (stateManager as any).getProviderState("expired-provider");
      const normalState = await (stateManager as any).getProviderState("normal-provider");

      // Verify out of credits provider is marked as such
      const isOutOfCredits =
        outOfCreditsState.outOfCreditsUntil &&
        new Date(outOfCreditsState.outOfCreditsUntil) > new Date();
      expect(isOutOfCredits).toBe(true);

      // Verify expired provider is not marked as out of credits anymore
      const isExpiredOutOfCredits =
        expiredState.outOfCreditsUntil && new Date(expiredState.outOfCreditsUntil) > new Date();
      expect(isExpiredOutOfCredits).toBe(false);

      // Verify normal provider is not marked as out of credits
      const isNormalOutOfCredits =
        normalState.outOfCreditsUntil && new Date(normalState.outOfCreditsUntil) > new Date();
      expect(isNormalOutOfCredits).toBe(false);
    });
  });
});
